# 물리 모델링 및 설계
## 물리 모델링이란
물리 모델링은 논리 모델을 데이터베이스 종류에 맞게 데이터를 저장할 수 있는 스키마 구조로 변환하는 과정이다. 엔티티 및 서브타입을 테이블로 변환하고, 속성을 컬럼으로 변환, 관계 및 무결성을 설계, 성능 향상을 위해 엔티티를 반정규화 하거나 중복 컬럼을 추가하여 설계한다.

## 테이블 설계
관계형 모델에서는 논리 데이터 모델을 테이블로 변환해야 한다. 테이블명은 테이블 명명규칙에 따라 엔티티명에 대한 데이터 표준을 적용하여 부여한다. 테이블에서는 슈퍼타입/서브타입 구조를 직접 표현할 수 없다. 슈퍼타입 기준으로 통합하여 설계하거나 서브타입 엔티티 기준으로 설계하거나 각각의 테이블로 설계한다.

__슈퍼타입 기준 테이블 설계__ : 서브타입의 엔티티의 모든 속성을 슈퍼타입 엔티티로 옮기고 관계를 추가한뒤 서브타입 엔티티를 삭제하고, 슈퍼타입 엔티티에 테이블 명을 부여한다. 여러 테이블을 조인할 필요가 없어 개발 생산성이 향상되고, 유사한 특징을 가지는 속성은 일반화하여 한 컬럼으로 설계할 수 있다. 한 컬럼으로 설계시 일반화되어 의미가 희석될 수 있으나 Not Null을 지정할 수 있고, 분기처리를 하지 않아도 된다.

__서브타입 기준 테이블 설계__ : 서브타입 단위로 테이블을 생성, 슈퍼타입 엔티티에서 관리하는 속성이 적거나, 응용프로그램에서 슈퍼타입 엔티티를 사용하는 경우가 별로 없을 때, 서브타입 엔티티의 속성이 명확히 구분되거나 차이가 심할 경우 서브타입 기준으로 테이블을 생성한다. 단점으로 여러 테이블을 처리하게 되어 프로그램이 복잡해지고, 유형이 추가되는 경우 테이블을 추가하고, 프로그램도 변경해야한다.

__슈퍼타입/서브타입 테이블 설계__ : 슈퍼타입, 서브타입 엔티티를 개별 테이블로 설계하는 방식 1:1 관계로 정의한다. 전체 데이터에 대해 공통적인 속성을 처리할 때는 슈퍼타입 테이블을 읽어 처리하고, 서브타입 테이블에서 관리하는 데이터를 화면에서 상세 조회하는 경우 서브타입 테이블을 읽어 처리할 수 있다.

## 관계 설계
### 기본적인 관계
참조 관계에 의해 부모 테이블의 PK 컬럼을 자식 테이블에서 PK 컬럼으로 상속받거나 일반 컬럼으로 상속받게 된다.

### 상호배타적 관계
DBMS는 상호배타적 관계를 지원하지 않는다. 논리적으로 수용할 수 있도록 테이블을 설계해야하는데 방법은 참조 컬럼을 한 컬럼으로 통합하여 설계하는 방법과 개별 컬럼으로 분리하는 방법이 있다.

컬럼을 분리하는 방법은 복잡해지므로 가급적이면 컬럼을 통합하여 설계한다.

__컬럼을 통합__ 하는 방법은 상호배타적 관계에 참여한 모든 관계를 동일한 컬럼으로 변환하고, 어떤 테이블을 참조하는지는 별도 구분 컬럼을 추가하여 구분한다. 통합 컬럼은 NOT NULL을 지정할 수 있고, 인덱스 수를 최소화할 수 있다.  __컬럼을 분리__ 하는 방법은 배타 관계를 개별 컬럼으로 변환한다. 또 통합과 마찬가지로 구분 컬럼을 추가하여 구분한다. 관계에 대해 FK 제약조건을 설정할 수 있는 장점이 있으나 NOT NULL을 지정할 수 없고, 개별 컬럼마다 인덱스를 생성해야 하는 단점이 있다. 

### 재귀적 관계
재귀적 관계에서 참조되는 컬럼은 PK가 되고, 참조하는 컬럼은 FK가 된다. FK 컬럼은 한 테이블 내에서 다른 로우의 PK 컬럼을 참조하며 FK와 PK컬럼으로 재귀 호출하여 결과를 추출한다. 오라클에서는 'START WITH ~ CONNECT BY ~ '을 통해 재귀호출을 쉽게 구현할 수 있다.

### 관계 옵셔널리티 확정
논리 모델링 단계에서 정확하지 않거나 모호하게 설계한 옵셔널리티를 검토하여 확정한다.
* Mandatory : 이 관계의 경우 부모 테이블에 데이터가 입력되면 자식 테이블에도 동시에 입력된다.
* 자식 Optional : 부모 테이블의 PK에 해당하는 데이터가 자식 테이블에 존재하지 않아도 된다.
* 양쪽 Optional : 부모 데이블에 데이터가 존재하지 않는 상태에서 자식 테이블에 데이터가 발생하는 유형이다.

## 컬럼 설계
컬럼은 관계형 데이터베이스의 테이블을 구성하는 열을 의미하며 데이터 타입과 길이를 가진다. 물리 모델링에서 속성을 컬럼으로 변환하는 과정은 복잡하지 않다. 논리 데이터모델의 속성에 대해 표준용어와 표준단어, 표준 도메인을 적용하는 작업이 대부분이다. 

### 속성-컬럼 변환
일반적으로 논리모델에서 정의한 속성은 물리 모델에서 거의 그대로 사용한다. 그리고 시스템에서 데이터에 대한 변화를 추적하고, 트랜잭션을 관리하기 위해 시스템 컬럼을 추가할 수 있다. (최초등록일시, 등록자식별번호, 수정일시, 수정자식별번호 등) 이러한 시스템 컬럼은 모든 테이블에 공통으로 추가하며 테이블 가장 마지막에 위치하도록 한다.

### 컬럼명 부여
일반적으로 컬럼명은 속성명을 구성하는 표준단어의 영문약어 조합으로 부여한다. 

### 데이터 타입 및 길이 지정
* CHAR : 고정길이 문자 데이터 타입, 정의된 길이만큼 공백을 채우므로 저장공간을 낭비할 수 있다.
* VARCAHR2 : 가변길이 문자 데이터타입 정의된 길이만큼 공백을 채우지 않는다.
* NCHAR/NVARCHAR(n) : 유니코드 형식의 데이터를 포함하는 고정길이 또는 가변길이 문자 데이터타입이다. n은 바이트가 아닌 문자길이를 나타낸다.
* NUMBER : 숫자 타입
* DATE : 고정길이 7바이트의 날짜와 시간

1)실제 개발에서는 CHAR, VARCHAR2 중 어느것을 적용해야할까? CHAR이 크게 나은점이 없기 때문에 개발의 혼란을 피하기 위해서 두개를 혼용해서 사용하기 보다는 VARCHAR2만 사용하는 것이 좋다.

2)일자 컬럼을 지정할때 VARCHAR2, DATE 중 고민하게 된다. 데이터 품질을 우선 고려한다면 DATE 타입을 적용하는 것이 좋고, VARCHAR2 타입으로 하는 경우 제약조건을 추가하거나 인덱스를 만들어서 오류 데이터가 입력되지 않도록 한다.

다른 테이블과 참조 관계에 있는 컬럼은 반드시 동일한 데이터 타입과 길이를 가지도록 하고, 유사한 정보를 관리하는 컬럼에 대해 일관성을 유지할 수 있도록 설계하는 것이 좋다.

### 기본키(PK) 지정
논리 데이터모델의 주 식별자를 기본키로 생성한다. 기본키는 유일해야하고, NOT NULL이어야한다. 테이블을 생성하면서 기본키 제약조건과 Unique 인덱스를 같이 생성한다. 

기본키를 자체 컬럼으로 구성하는 경우는 보통 핵심 엔티티나 중요 엔티티에 해당하는 테이블이고, 데이터에 대한 일정한 채번규칙을 가지고 있다. 일관된 채번 규칙과 데이터 타입을 적용하도록 하자. 부모 테이블의 기본키를 상속받아 구성하는 경우는 상속받은 컬럼에 숫자형 데이터타입을 가지는 일련번호 컬럼을 추가하는 형태가 일반적이다. 참조하는 컬럼과 동일한 데이터타입과 길이로 정의한다.

## 데이터 무결성 설계
데이터 무결성은 데이터를 저장하고 관리할 때 데이터의 정확성과 일관성을 유지하기 위해 사전에 정의한 규칙이다. 데이터 무결성을 통해 데이터의 정확성, 일관성, 유효성, 신뢰성을 확보할 수 있고, 무효 갱신으로부터 데이터를 보호할 수 있다.

* 실체 무결성 : 기본키와 관련된 제약조건으로 모든 실체는 식별자를 가지고 있으며 그 식별자는 NOT NULL이고, 실체 내에서 유일한 값이어야 한다.(PK, unique 제약조건이 해당)
* 영역 무결성 : 데이터 속성 값들은 정해진 데이터 범위를 벗어나지 않아야 하며, 데이터 타입, 길이, 유효값을 일관되게 유지해야한다.(CHECK, DEFAULT, NOT NULL 해당)
* 참조 무결성 : 데이터 모델에서 정의된 실체 간의 관계 조건을 유지하는 것이다. 참조하는 테이블은 참조할 수 없는 외래 키를 가져서는 안되며, 참조되는 테이블은 외래키가 존재하는 한 데이터를 삭제하거나 변경할 수 없다.

## 성능을 고려한 데이터 구조
시스템을 운영하는 과정에서 DB 튜닝을 하다보면 튜닝 된 결과를 반영하는 일이 쉽지 만은 않다. 향후 운영 중에 이러한 성능 문제가 발생하지 않도록 물리 모델링 단계에서 대량의 데이터를 빈번하게 처리하거나 특정 범위를 자주 처리하는 경우가 있는지 확인하여 테이블을 설계해야한다.

* 집계/요약 테이블 추가 : 원천 테이블에서 대량의 데이터를 실시간으로 읽어, 일자나 부서 단위로 집계하거나 업무 데이터를 처리하면서 일부 데이터를 집계하는 경우 집계 테이블을 추가할 수 있다.
* 컬럼 추가 : 정규화를 충실하게 한 경우 컬럼 중복으로 인한 오류 데이터 유입을 최소화할 수 있고, 일관성 있는 데이터를 유지할 수 있다. 하지만 성능 문제때문에 반정규화 하거나 중복 컬럼을 추가해야하는 경우도 있다. 하지만 데이터에 대한 일관성을 유지하는 데 많은 노력이 필요하므로 남용해서는 안된다.
* 테이블 분할 : 데이터를 처리할 때 컬럼과 로우인 면적이 처리범위가 된다. 면적을 줄이기 위해서는 컬럼을 줄이거나(수직분할) 로우를 줄이는(수평분할) 방법이 있다. 

## 물리설계
물리 모델링 이후 DBMS 특성을 고려하여 성능, 관리, 보안, 개발생산성의 목적에 맞도록 물리적인 설계를 한다.

* 테이블, 인덱스 : 데이터를 저장하고 관리하는 오브젝트 (인덱스는 저장된 데이터를 빠르게 접근할 수 있도록 설계됨)
* 파티션, 클러스터 : 데이터 처리를 효율적으로 하기 위해 데이터를 저장하는 방식에 초점

뷰, 함수등의 오브젝트는 데이터를 저장하지 않으며 물리 설계시 특별히 고려할 사항이 많지 않으므로 생략한다. 성능 관점에서 설계 요소를 살펴보면 실시간 업무처리를 하는 경우 소량의 데이터를 빠르게 처리해야한다. 주로 인덱스를 경유하여 테이블을 읽게 되며 Nested Loops 조인 방법을 사용한다. 대량의 데이터를 배치로 처리하는 업무는 인덱스를 경유할 경우 대량의 랜덤 액세스로 인해 성능 문제가 발생한다. 이때는 인덱스를 사용하지 않고 직접 테이블을 읽어 처리하는 편이 나을 수 있다. 테이블을 처리하더라도 가급적 필요한 데이터만 처리하기 위해 파티션이나 클러스터 테이블 설계를 고려해야한다. 파티션은 성능적인 목적도 있지만 데이터를 보관하고 폐기하기 위한 관리적인 목적에서 설계하기도 한다.

### 오브젝트 명명 규칙
* 오브젝트 구분 : T(테이블), V(뷰), S(시퀀스), F(함수), P(프로시저)
* 주제영역 : 주제영역에 대한 영문 약어 2자리를 사용 (예. CU:고객, PD:상품)
* 영문약어 : 오브젝트 명에 대한 영문 약어명을 사용하고, 단어와 단어 사이는 언더바로 구분한다.
* 일련번호 : 01~99 순차적으로 부여

테이블 명명 규칙은 이해관계자와 협의하여 정하는 것이 좋다.

## 인덱스 설계
인덱스는 책의 색인을 생각하면 된다. 인덱스는 테이블에서 전체 데이터를 읽지 않고, 조회하고자 하는 데이터를 쉽게 찾을 수 있도록 설계된 자료구조이다. 특정 컬럼들의 데이터 값으로 정렬된 형태로 구성되어 있으며 테이블의 행을 찾아갈 수 있도록 테이블 행 주소(RowID)를 가지고 있다.

### 인덱스 구조
B-Tree 인덱스는 루트노드, 브렌치노드, 리프노드로 구성된다. 조건절의 데이터를 찾기위해 루트노드에서 브렌치 노드로 이동, 브렌치 노드에서 리프노드로 이동한다. 마지막으로 리프 노드에서 해당 값과 동일한 값을 찾아 RowID를 이용하여 테이블 데이터를 액세스한다.

### 인덱스 활용 방법
인덱스를 사용하는 가장 기본적인 이유는 소량의 데이터를 빠르게 찾기 위함이다. 인덱스를 잘 이용하면 order by절을 기술해도 별도의 정렬작업을 피할 수 있고, 쿼리에서 사용하는 컬럼이 모두 인덱스 컬럼에 포함되어 있다면 테이블을 읽지 않고 인덱스만 읽어 데이터를 추출할 수 있다.

SQL Server는 인덱스에 키 컬럼이 아닌 일반 컬럼을 추가할 수 있는 '포괄 열 옵션'을 제공한다.

예) CREATE INDEX EMP_IX01 ON EMP(DEPT_CD) __INCLUDE__ (EMP_NO, EMP_NM);

인덱스 키 컬럼 DEPT_CD은 루트, 브렌치, 리프 페이지 모두를 구성하고, 정렬되어 저장된다. 하지만 include 절에 기술한 포괄 열 컬럼 EMP_NO, EMP_NM은 인덱스의 루트, 브렌치 페이지를 구성하는 비용은 없으면서 테이블 액세스를 줄일 수 있다.

또 주문 상태와 같이 편차가 심한 데이터를 효과적으로 처리하기 위해 함수기반 인덱스를 만들어 활용할 수 있다.

예) CREATE INDEX ORD_IX01 ON ORD(UPPER(ORD_STAT_CD));

WHERE UPPER(ORD_STAT_CD) = '주문'  (인덱스 사용)

WHERE ORD_STAT_CD = '주문완료'  (테이블 스캔)

SQL Server에서는 함수기반 인덱스 대신 인덱스를 생성할 때 필터 옵션을 추가하여 구현할 수 있다. 인덱스 생성시 WHERE 조건을 추가할 수 있으며 조건에 해당하는 데이터만으로 인덱스를 생성하므로 조건에 해당하지 않으면 인덱스를 사용하지 않게 된다.

### 인덱스 설계 방법
인덱스 설계는 설계 단계와 개발 단계로 나누어 진행할 수 있다. 설계 단계에서는 데이터 모델을 바탕으로 테이블을 만들면서 기본으로 PK 인덱스를 생성하고, 식별된 FK에 해당하는 인덱스를 생성한다. 개발 단계에서는 테이블 단위로 사용하는 쿼리의 액세스 형태를 분석하여 인덱스를 설계하고, 개발이 어느정도 완료되면 테이블 단위로 전체 쿼리를 대상으로 액세스 형태를 조사하고 분석해야한다.

모든 테이블을 대상으로 액세스 유형을 조사하고 분석하려면 시간과 비용이 많이 드므로 주요 테이블을 선정하여 진행하는 것이 효율적이다. 대상 테이블을 선정하였으면 쿼리를 분석하여 액세스 유형을 조사한다. 컬럼에 대한 분포도를 조사하여 액세스 패턴에 해당하는 데이터 처리량 등을 고려하여 인덱스를 설계한다.

컬럼값에 대한 종류가 많을수록 인덱스 대상 컬럼으로 우선 적용할 수 있다. 액세스 유형과 값의 분포를 감안하여 인덱스를 추가하거나 기존 인덱스에 컬럼을 추가하여 인덱스를 설계한다. 인덱스 설계시 식별자 컬럼을 우선 설계 대상으로 고려할 수 있다. 코드와 일자 컬럼의 경우 코드 컬럼에 해당하는 조건이 항상 조회 조건에 포함된다면 코드 컬럼을 선두 컬럼으로 고려할 수 있고, 그렇지 않다면 코드 컬럼보다는 일자 컬럼을 우선 고려해야한다. 

### 클러스터형 인덱스
클러스터형 인덱스는 SQL Server의 인덱스이면서 테이블인 오브젝트를 말한다. 클러스터형 인덱스는 테이블을 특정 컬럼 기준으로 정렬하여 저장한다. 인텍스 키가 아닌 모든 컬럼에 해당하는 데이터를 리프 페이지에서 같이 관리한다. 인덱스 키로 인덱스 구조를 만들어 인덱스 키로 데이터를 정렬하고, 리프 페이지에서 나머지 모든 데이터를 저장한다. 테이블 로우는 한 가지 기준으로만 정렬될 수 있으므로 클러스터형 인덱스는 테이블당 한 개만 만들 수 있다.

클러스터형 인덱스는 리프 페이지에서 RID를 관리하지 않는다. 비클러스터형 인덱스를 추가하게 되면 RID 대신 클러스터형 키 값을 가지게 된다. 클러스터형 인덱스로 테이블을 설계하면 조회하는 속도는 빠르다. (데이터 입력 시 키 값으로 정렬하여 저장하기 때문)